#![doc = "Peripheral access API for TARGET microcontrollers (generated using svd2rust v0.28.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.28.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn PMU();
    fn RTC();
    fn U32K0();
    fn U32K1();
    fn I2C();
    fn SPI1();
    fn UART0();
    fn UART1();
    fn UART2();
    fn UART3();
    fn UART4();
    fn UART5();
    fn ISO78160();
    fn ISO78161();
    fn TMR0();
    fn TMR1();
    fn TMR2();
    fn TMR3();
    fn PWM0();
    fn PWM1();
    fn PWM2();
    fn PWM3();
    fn DMA();
    fn FLASH();
    fn ANA();
    fn SPI2();
    fn SPI3();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 29] = [
    Vector { _handler: PMU },
    Vector { _handler: RTC },
    Vector { _handler: U32K0 },
    Vector { _handler: U32K1 },
    Vector { _handler: I2C },
    Vector { _handler: SPI1 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _handler: UART2 },
    Vector { _handler: UART3 },
    Vector { _handler: UART4 },
    Vector { _handler: UART5 },
    Vector { _handler: ISO78160 },
    Vector { _handler: ISO78161 },
    Vector { _handler: TMR0 },
    Vector { _handler: TMR1 },
    Vector { _handler: TMR2 },
    Vector { _handler: TMR3 },
    Vector { _handler: PWM0 },
    Vector { _handler: PWM1 },
    Vector { _handler: PWM2 },
    Vector { _handler: PWM3 },
    Vector { _handler: DMA },
    Vector { _handler: FLASH },
    Vector { _handler: ANA },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: SPI2 },
    Vector { _handler: SPI3 },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - PMU"]
    PMU = 0,
    #[doc = "1 - RTC"]
    RTC = 1,
    #[doc = "2 - U32K0"]
    U32K0 = 2,
    #[doc = "3 - U32K1"]
    U32K1 = 3,
    #[doc = "4 - I2C"]
    I2C = 4,
    #[doc = "5 - SPI1"]
    SPI1 = 5,
    #[doc = "6 - UART0"]
    UART0 = 6,
    #[doc = "7 - UART1"]
    UART1 = 7,
    #[doc = "8 - UART2"]
    UART2 = 8,
    #[doc = "9 - UART3"]
    UART3 = 9,
    #[doc = "10 - UART4"]
    UART4 = 10,
    #[doc = "11 - UART5"]
    UART5 = 11,
    #[doc = "12 - ISO78160"]
    ISO78160 = 12,
    #[doc = "13 - ISO78161"]
    ISO78161 = 13,
    #[doc = "14 - TMR0"]
    TMR0 = 14,
    #[doc = "15 - TMR1"]
    TMR1 = 15,
    #[doc = "16 - TMR2"]
    TMR2 = 16,
    #[doc = "17 - TMR3"]
    TMR3 = 17,
    #[doc = "18 - PWM0"]
    PWM0 = 18,
    #[doc = "19 - PWM1"]
    PWM1 = 19,
    #[doc = "20 - PWM2"]
    PWM2 = 20,
    #[doc = "21 - PWM3"]
    PWM3 = 21,
    #[doc = "22 - DMA"]
    DMA = 22,
    #[doc = "23 - FLASH"]
    FLASH = 23,
    #[doc = "24 - ANA"]
    ANA = 24,
    #[doc = "27 - SPI2"]
    SPI2 = 27,
    #[doc = "28 - SPI3"]
    SPI3 = 28,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "The Analog controller is used to control the analog function of TARGET."]
pub struct ANA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ANA {}
impl ANA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ana::RegisterBlock = 0x4001_4200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ana::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ANA {
    type Target = ana::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ANA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ANA").finish()
    }
}
#[doc = "The Analog controller is used to control the analog function of TARGET."]
pub mod ana;
#[doc = "CRYPT accelerate the sign and verify process speed of ECC."]
pub struct CRYPT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRYPT {}
impl CRYPT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crypt::RegisterBlock = 0x4000_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crypt::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CRYPT {
    type Target = crypt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CRYPT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRYPT").finish()
    }
}
#[doc = "CRYPT accelerate the sign and verify process speed of ECC."]
pub mod crypt;
#[doc = "DMA(Direct Memory Access)"]
pub struct DMA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA {}
impl DMA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dma::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dma::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA {
    type Target = dma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA").finish()
    }
}
#[doc = "DMA(Direct Memory Access)"]
pub mod dma;
#[doc = "FLASH Register"]
pub struct FLASH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASH {}
impl FLASH {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flash::RegisterBlock = 0x000f_ff00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flash::RegisterBlock {
        Self::PTR
    }
}
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FLASH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FLASH").finish()
    }
}
#[doc = "FLASH Register"]
pub mod flash;
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub struct GPIOA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA {}
impl GPIOA {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_4010 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOA {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOA").finish()
    }
}
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub mod gpioa;
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub struct GPIOB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOB {}
impl GPIOB {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpiob::RegisterBlock = 0x4000_0020 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiob::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOB {
    type Target = gpiob::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOB").finish()
    }
}
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub mod gpiob;
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub struct GPIOC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOC {}
impl GPIOC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpiob::RegisterBlock = 0x4000_0040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiob::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOC {
    type Target = gpiob::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOC").finish()
    }
}
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub use self::gpiob as gpioc;
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub struct GPIOD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOD {}
impl GPIOD {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpiob::RegisterBlock = 0x4000_0060 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiob::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOD {
    type Target = gpiob::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOD").finish()
    }
}
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub use self::gpiob as gpiod;
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub struct GPIOE {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOE {}
impl GPIOE {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpiob::RegisterBlock = 0x4000_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiob::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOE {
    type Target = gpiob::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOE {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOE").finish()
    }
}
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub use self::gpiob as gpioe;
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub struct GPIOF {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOF {}
impl GPIOF {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpiob::RegisterBlock = 0x4000_00a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiob::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOF {
    type Target = gpiob::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOF {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOF").finish()
    }
}
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub use self::gpiob as gpiof;
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub struct GPIOAF {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOAF {}
impl GPIOAF {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpioaf::RegisterBlock = 0x4000_00c0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpioaf::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOAF {
    type Target = gpioaf::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOAF {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOAF").finish()
    }
}
#[doc = "The GPIO controller is used to control the GPIOs of TARGET."]
pub mod gpioaf;
#[doc = "I2C-Inter Integrated Circuit"]
pub struct I2C {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C {}
impl I2C {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c::RegisterBlock = 0x4001_0800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C {
    type Target = i2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C").finish()
    }
}
#[doc = "I2C-Inter Integrated Circuit"]
pub mod i2c;
#[doc = "The ISO7816 controller is an enhance UART protocol which is able to do half-duplex communication on the 2 wires bus."]
pub struct ISO78160 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ISO78160 {}
impl ISO78160 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iso78160::RegisterBlock = 0x4001_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iso78160::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ISO78160 {
    type Target = iso78160::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ISO78160 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ISO78160").finish()
    }
}
#[doc = "The ISO7816 controller is an enhance UART protocol which is able to do half-duplex communication on the 2 wires bus."]
pub mod iso78160;
#[doc = "The ISO7816 controller is an enhance UART protocol which is able to do half-duplex communication on the 2 wires bus."]
pub struct ISO78161 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ISO78161 {}
impl ISO78161 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iso78160::RegisterBlock = 0x4001_2040 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iso78160::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ISO78161 {
    type Target = iso78160::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ISO78161 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ISO78161").finish()
    }
}
#[doc = "The ISO7816 controller is an enhance UART protocol which is able to do half-duplex communication on the 2 wires bus."]
pub use self::iso78160 as iso78161;
#[doc = "The LCD controller is used to display content on the LCD panel."]
pub struct LCD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LCD {}
impl LCD {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lcd::RegisterBlock = 0x4000_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lcd::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LCD {
    type Target = lcd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LCD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LCD").finish()
    }
}
#[doc = "The LCD controller is used to display content on the LCD panel."]
pub mod lcd;
#[doc = "The MISC controller is used to control some special function of TARGET, which will be power-off during sleep and deep-sleep mode."]
pub struct MISC1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MISC1 {}
impl MISC1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const misc1::RegisterBlock = 0x4001_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const misc1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for MISC1 {
    type Target = misc1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MISC1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MISC1").finish()
    }
}
#[doc = "The MISC controller is used to control some special function of TARGET, which will be power-off during sleep and deep-sleep mode."]
pub mod misc1;
#[doc = "MISC2 controller is in retention domain which will be power-off at deep-sleep mode."]
pub struct MISC2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for MISC2 {}
impl MISC2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const misc2::RegisterBlock = 0x4001_3e00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const misc2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for MISC2 {
    type Target = misc2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for MISC2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MISC2").finish()
    }
}
#[doc = "MISC2 controller is in retention domain which will be power-off at deep-sleep mode."]
pub mod misc2;
#[doc = "Power Management Unit."]
pub struct PMU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PMU {}
impl PMU {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmu::RegisterBlock = 0x4001_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmu::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PMU {
    type Target = pmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PMU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PMU").finish()
    }
}
#[doc = "Power Management Unit."]
pub mod pmu;
#[doc = "Timers are 16 bits timers with PWM and capture function."]
pub struct PWM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM0 {}
impl PWM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4001_2900 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM0 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM0").finish()
    }
}
#[doc = "Timers are 16 bits timers with PWM and capture function."]
pub mod pwm0;
#[doc = "Timers are 16 bits timers with PWM and capture function."]
pub struct PWM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM1 {}
impl PWM1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4001_2920 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM1 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM1").finish()
    }
}
#[doc = "Timers are 16 bits timers with PWM and capture function."]
pub use self::pwm0 as pwm1;
#[doc = "Timers are 16 bits timers with PWM and capture function."]
pub struct PWM2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM2 {}
impl PWM2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4001_2940 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM2 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM2").finish()
    }
}
#[doc = "Timers are 16 bits timers with PWM and capture function."]
pub use self::pwm0 as pwm2;
#[doc = "Timers are 16 bits timers with PWM and capture function."]
pub struct PWM3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM3 {}
impl PWM3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4001_2960 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM3 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM3").finish()
    }
}
#[doc = "Timers are 16 bits timers with PWM and capture function."]
pub use self::pwm0 as pwm3;
#[doc = "Timers are 16 bits timers with PWM and capture function."]
pub struct PWM_SEL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWM_SEL {}
impl PWM_SEL {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm_sel::RegisterBlock = 0x4001_29f0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm_sel::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWM_SEL {
    type Target = pwm_sel::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWM_SEL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWM_SEL").finish()
    }
}
#[doc = "Timers are 16 bits timers with PWM and capture function."]
pub mod pwm_sel;
#[doc = "The RTC controller is used to control time calculation and RTC auto calibration function."]
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const rtc::RegisterBlock = 0x4001_4800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTC").finish()
    }
}
#[doc = "The RTC controller is used to control time calculation and RTC auto calibration function."]
pub mod rtc;
#[doc = "SPI(Serial Peripheral Interface)."]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi1::RegisterBlock = 0x4001_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
#[doc = "SPI(Serial Peripheral Interface)."]
pub mod spi1;
#[doc = "SPI(Serial Peripheral Interface)."]
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi1::RegisterBlock = 0x4001_5800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI2 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI2").finish()
    }
}
#[doc = "SPI(Serial Peripheral Interface)."]
pub use self::spi1 as spi2;
#[doc = "SPI(Serial Peripheral Interface)."]
pub struct SPI3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI3 {}
impl SPI3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spi1::RegisterBlock = 0x4001_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI3 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI3").finish()
    }
}
#[doc = "SPI(Serial Peripheral Interface)."]
pub use self::spi1 as spi3;
#[doc = "General purpose 32 bits timer, which are used to generate regulate interrupt for CM0."]
pub struct TMR0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR0 {}
impl TMR0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr0::RegisterBlock = 0x4001_2800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR0 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR0").finish()
    }
}
#[doc = "General purpose 32 bits timer, which are used to generate regulate interrupt for CM0."]
pub mod tmr0;
#[doc = "General purpose 32 bits timer, which are used to generate regulate interrupt for CM0."]
pub struct TMR1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR1 {}
impl TMR1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr0::RegisterBlock = 0x4001_2820 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR1 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR1").finish()
    }
}
#[doc = "General purpose 32 bits timer, which are used to generate regulate interrupt for CM0."]
pub use self::tmr0 as tmr1;
#[doc = "General purpose 32 bits timer, which are used to generate regulate interrupt for CM0."]
pub struct TMR2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR2 {}
impl TMR2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr0::RegisterBlock = 0x4001_2840 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR2 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR2").finish()
    }
}
#[doc = "General purpose 32 bits timer, which are used to generate regulate interrupt for CM0."]
pub use self::tmr0 as tmr2;
#[doc = "General purpose 32 bits timer, which are used to generate regulate interrupt for CM0."]
pub struct TMR3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR3 {}
impl TMR3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr0::RegisterBlock = 0x4001_2860 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TMR3 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR3").finish()
    }
}
#[doc = "General purpose 32 bits timer, which are used to generate regulate interrupt for CM0."]
pub use self::tmr0 as tmr3;
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4001_1800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub mod uart0;
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4001_1820 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART1 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub use self::uart0 as uart1;
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4001_1840 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART2 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub use self::uart0 as uart2;
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4001_1860 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART3 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART3").finish()
    }
}
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub use self::uart0 as uart3;
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub struct UART4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART4 {}
impl UART4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4001_1880 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART4 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART4").finish()
    }
}
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub use self::uart0 as uart4;
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub struct UART5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART5 {}
impl UART5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4001_18a0 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART5 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART5").finish()
    }
}
#[doc = "UART(Universal Asynchronous Receiver/Transmitter)."]
pub use self::uart0 as uart5;
#[doc = "The UART 32K controller is used to receive data via UART protocol."]
pub struct U32K0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for U32K0 {}
impl U32K0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const u32k0::RegisterBlock = 0x4001_4100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const u32k0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for U32K0 {
    type Target = u32k0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for U32K0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("U32K0").finish()
    }
}
#[doc = "The UART 32K controller is used to receive data via UART protocol."]
pub mod u32k0;
#[doc = "The UART 32K controller is used to receive data via UART protocol."]
pub struct U32K1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for U32K1 {}
impl U32K1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const u32k0::RegisterBlock = 0x4001_4180 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const u32k0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for U32K1 {
    type Target = u32k0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for U32K1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("U32K1").finish()
    }
}
#[doc = "The UART 32K controller is used to receive data via UART protocol."]
pub use self::u32k0 as u32k1;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "ANA"]
    pub ANA: ANA,
    #[doc = "CRYPT"]
    pub CRYPT: CRYPT,
    #[doc = "DMA"]
    pub DMA: DMA,
    #[doc = "FLASH"]
    pub FLASH: FLASH,
    #[doc = "GPIOA"]
    pub GPIOA: GPIOA,
    #[doc = "GPIOB"]
    pub GPIOB: GPIOB,
    #[doc = "GPIOC"]
    pub GPIOC: GPIOC,
    #[doc = "GPIOD"]
    pub GPIOD: GPIOD,
    #[doc = "GPIOE"]
    pub GPIOE: GPIOE,
    #[doc = "GPIOF"]
    pub GPIOF: GPIOF,
    #[doc = "GPIOAF"]
    pub GPIOAF: GPIOAF,
    #[doc = "I2C"]
    pub I2C: I2C,
    #[doc = "ISO78160"]
    pub ISO78160: ISO78160,
    #[doc = "ISO78161"]
    pub ISO78161: ISO78161,
    #[doc = "LCD"]
    pub LCD: LCD,
    #[doc = "MISC1"]
    pub MISC1: MISC1,
    #[doc = "MISC2"]
    pub MISC2: MISC2,
    #[doc = "PMU"]
    pub PMU: PMU,
    #[doc = "PWM0"]
    pub PWM0: PWM0,
    #[doc = "PWM1"]
    pub PWM1: PWM1,
    #[doc = "PWM2"]
    pub PWM2: PWM2,
    #[doc = "PWM3"]
    pub PWM3: PWM3,
    #[doc = "PWM_SEL"]
    pub PWM_SEL: PWM_SEL,
    #[doc = "RTC"]
    pub RTC: RTC,
    #[doc = "SPI1"]
    pub SPI1: SPI1,
    #[doc = "SPI2"]
    pub SPI2: SPI2,
    #[doc = "SPI3"]
    pub SPI3: SPI3,
    #[doc = "TMR0"]
    pub TMR0: TMR0,
    #[doc = "TMR1"]
    pub TMR1: TMR1,
    #[doc = "TMR2"]
    pub TMR2: TMR2,
    #[doc = "TMR3"]
    pub TMR3: TMR3,
    #[doc = "UART0"]
    pub UART0: UART0,
    #[doc = "UART1"]
    pub UART1: UART1,
    #[doc = "UART2"]
    pub UART2: UART2,
    #[doc = "UART3"]
    pub UART3: UART3,
    #[doc = "UART4"]
    pub UART4: UART4,
    #[doc = "UART5"]
    pub UART5: UART5,
    #[doc = "U32K0"]
    pub U32K0: U32K0,
    #[doc = "U32K1"]
    pub U32K1: U32K1,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            ANA: ANA {
                _marker: PhantomData,
            },
            CRYPT: CRYPT {
                _marker: PhantomData,
            },
            DMA: DMA {
                _marker: PhantomData,
            },
            FLASH: FLASH {
                _marker: PhantomData,
            },
            GPIOA: GPIOA {
                _marker: PhantomData,
            },
            GPIOB: GPIOB {
                _marker: PhantomData,
            },
            GPIOC: GPIOC {
                _marker: PhantomData,
            },
            GPIOD: GPIOD {
                _marker: PhantomData,
            },
            GPIOE: GPIOE {
                _marker: PhantomData,
            },
            GPIOF: GPIOF {
                _marker: PhantomData,
            },
            GPIOAF: GPIOAF {
                _marker: PhantomData,
            },
            I2C: I2C {
                _marker: PhantomData,
            },
            ISO78160: ISO78160 {
                _marker: PhantomData,
            },
            ISO78161: ISO78161 {
                _marker: PhantomData,
            },
            LCD: LCD {
                _marker: PhantomData,
            },
            MISC1: MISC1 {
                _marker: PhantomData,
            },
            MISC2: MISC2 {
                _marker: PhantomData,
            },
            PMU: PMU {
                _marker: PhantomData,
            },
            PWM0: PWM0 {
                _marker: PhantomData,
            },
            PWM1: PWM1 {
                _marker: PhantomData,
            },
            PWM2: PWM2 {
                _marker: PhantomData,
            },
            PWM3: PWM3 {
                _marker: PhantomData,
            },
            PWM_SEL: PWM_SEL {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            SPI3: SPI3 {
                _marker: PhantomData,
            },
            TMR0: TMR0 {
                _marker: PhantomData,
            },
            TMR1: TMR1 {
                _marker: PhantomData,
            },
            TMR2: TMR2 {
                _marker: PhantomData,
            },
            TMR3: TMR3 {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
            UART4: UART4 {
                _marker: PhantomData,
            },
            UART5: UART5 {
                _marker: PhantomData,
            },
            U32K0: U32K0 {
                _marker: PhantomData,
            },
            U32K1: U32K1 {
                _marker: PhantomData,
            },
        }
    }
}
